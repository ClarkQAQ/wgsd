# wgsd

[English README](README.en.md)

Wireguard peer discover helper (Wireguard 对等发现助手)

> 众所周知 Wireguard 是点对点的 VPN 协议, 但是大部分人或者教程都是使用辐射状的拓扑结构, 也就是说每个节点要和其他节点连接都要经过中心节点, 但是想实现 P2P 又会由于 Wireguard 没有内置设备发现的原因需要两个节点又一方是固定公网或者每次都手动修改配置文件, 这个工具就是为了解决这个问题而生的!

### 原理

其实很简单, 就是在每个节点上都运行一个服务, 中心节点不做数据交换了, 而是用于设备发现, 每个服务的职能是从指定的地址获取本地公钥对应的设备的对等地址以及服务其他设备获取本地已连接的所有设备的对等地址, 有点类似简化版的 DHT (分布式 HASH 表网络结构) (虽然差得远了)

比如我有如下设备:

| 设备名称 | 公网地址 (地址+端口)       | 对等地址 |
| -------- | -------------------------- | -------- |
| A        | 10.0.114.1:19198           | 10.0.6.1 |
| B        | 地址转换: 10.0.114.2:11451 | 10.0.6.2 |
| C        | 地址转换: 10.0.114.2:11452 | 10.0.6.3 |

这种情况下通常会在 B, C 上配置 A 作为对等点, 但是假如我需要 B 和 C 通信怎么办, 虽然这里他们是在同一局域网能直接给双方互相配局域网对等地址
但是假如 B 和 C 是在两个网络, 这样很显然手动配置地址太麻烦, 并且每次连接都是地址转换的端口都是变化的...

解决方法:
用 wgsd 就能简化这个步骤, 首先在 A 上面运行 `./wgsd.bin -l :51220` (51220 是服务端口, 也就是其他节点要连接的端口), 然后在 B, C 上面运行 `./wgsd.bin -l :51221 -u 10.0.6.1:51220 "A"` (由于 A 有公网可以直连, 此刻 B, C 都是可以正常访问 10.0.6.1 这个地址的, 后面的 `"A"` 是 A 的公钥用来防止循环配置), 这样 B 就可以通过 A 的服务获取到 C 的对等地址 (反之亦然), 然后 B 就可以直接连接 C 了, 这样就实现了 P2P 的连接了!

并且每个 wgsd 可以同时为服务端和客户端所以这样能实现蜂窝结构网络发现!

### 使用

```bash
# 服务端
./wgsd -l :51220

# 客户端
./wgsd -l :51221 -u IP:51220 "服务端公钥" "可以多个公钥" (公钥用于防止循环配置)
```

### TODO

1. 客户端支持多个服务端
2. 在写入到 Wireguard 配置文件前先模拟握手检查是否能连接
3. 实现自动发现 wgsd 服务
